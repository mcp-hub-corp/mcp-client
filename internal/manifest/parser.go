package manifest

import (
	"encoding/json"
	"fmt"
	"regexp"
	"runtime"
	"strings"
)

// Manifest represents the complete MCP manifest structure
type Manifest struct {
	SchemaVersion string          `json:"schema_version"`
	Package       PackageInfo     `json:"package"`
	Bundle        BundleInfo      `json:"bundle"`
	Transport     TransportInfo   `json:"transport"`
	Entrypoints   []Entrypoint    `json:"entrypoints"`
	Permissions   PermissionsInfo `json:"permissions_requested"`
	Limits        LimitsInfo      `json:"limits_recommended"`
	// HubFormat indicates the manifest was parsed from hub format (no bundle/transport fields)
	HubFormat bool `json:"-"`
}

// PackageInfo contains package metadata
type PackageInfo struct {
	ID      string `json:"id"`      // "org/name"
	Version string `json:"version"` // semantic version
	GitSHA  string `json:"git_sha"` // git commit SHA
}

// BundleInfo contains bundle metadata
type BundleInfo struct {
	Digest    string `json:"digest"`     // SHA-256 digest
	SizeBytes int64  `json:"size_bytes"` // bundle size
}

// TransportInfo describes the transport mechanism
type TransportInfo struct {
	Type string `json:"type"` // "stdio" or "http"
	Port int    `json:"port,omitempty"`
}

// Entrypoint represents an executable entry point
type Entrypoint struct {
	OS      string   `json:"os"`      // "linux", "darwin", "windows"
	Arch    string   `json:"arch"`    // "amd64", "arm64"
	Command string   `json:"command"` // path to executable or system binary name
	Args    []string `json:"args,omitempty"`
}

// PermissionsInfo contains requested permissions
type PermissionsInfo struct {
	Network     []string `json:"network,omitempty"`     // allowlist of domains/IPs
	Environment []string `json:"environment,omitempty"` // env var allowlist
	Subprocess  bool     `json:"subprocess"`            // allow subprocess creation
	FileSystem  []string `json:"filesystem,omitempty"`  // filesystem paths allowlist
}

// LimitsInfo contains recommended resource limits
type LimitsInfo struct {
	MaxCPU    int    `json:"max_cpu"`    // millicores
	MaxMemory string `json:"max_memory"` // e.g. "512M"
	MaxPIDs   int    `json:"max_pids"`
	MaxFDs    int    `json:"max_fds"`
	Timeout   string `json:"timeout"` // e.g. "5m"
}

// Hub manifest types for parsing the format generated by mcp-hub

type hubManifest struct {
	SchemaVersion json.Number       `json:"schema_version"`
	Package       hubPackageInfo    `json:"package"`
	Runtime       hubRuntimeInfo    `json:"runtime"`
	Entrypoint    hubEntrypointInfo `json:"entrypoint"`
	Permissions   *hubPermissions   `json:"permissions,omitempty"`
	Resources     *hubResources     `json:"resources,omitempty"`
	Certification *hubCertification `json:"certification,omitempty"`
}

type hubPackageInfo struct {
	ID          string   `json:"id"`
	Version     string   `json:"version"`
	Description string   `json:"description,omitempty"`
	Repository  string   `json:"repository,omitempty"`
	License     string   `json:"license,omitempty"`
	GitSHA      string   `json:"git_sha,omitempty"`
	Keywords    []string `json:"keywords,omitempty"`
}

type hubRuntimeInfo struct {
	Type     string       `json:"type"`
	Version  string       `json:"version,omitempty"`
	Platform *hubPlatform `json:"platform,omitempty"`
}

type hubPlatform struct {
	OS   string `json:"os"`
	Arch string `json:"arch"`
}

type hubEntrypointInfo struct {
	Command []string          `json:"command"`
	Args    []string          `json:"args,omitempty"`
	Env     map[string]string `json:"env,omitempty"`
	Workdir string            `json:"workdir,omitempty"`
}

type hubPermissions struct {
	Network    *hubNetworkPerms    `json:"network,omitempty"`
	Filesystem *hubFilesystemPerms `json:"filesystem,omitempty"`
	EnvVars    []string            `json:"env_vars,omitempty"`
}

type hubNetworkPerms struct {
	Outbound []string `json:"outbound,omitempty"`
	Inbound  bool     `json:"inbound"`
}

type hubFilesystemPerms struct {
	Read    []string `json:"read,omitempty"`
	Write   []string `json:"write,omitempty"`
	Execute []string `json:"execute,omitempty"`
}

type hubResources struct {
	MemoryMB       int `json:"memory_mb,omitempty"`
	CPUMillicores  int `json:"cpu_millicores,omitempty"`
	TimeoutSeconds int `json:"timeout_seconds,omitempty"`
}

type hubCertification struct {
	Level int `json:"level"`
	Score int `json:"score"`
}

// Parse parses a manifest from JSON bytes, supporting both client and hub formats.
// Hub format is detected by the presence of "runtime" and "entrypoint" (singular) fields.
func Parse(data []byte) (*Manifest, error) {
	if len(data) == 0 {
		return nil, fmt.Errorf("manifest data cannot be empty")
	}

	// Detect format by checking for hub-specific fields
	var raw map[string]json.RawMessage
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, fmt.Errorf("failed to parse manifest JSON: %w", err)
	}

	// Hub manifest has "runtime" and "entrypoint" (singular); client has "entrypoints" (plural)
	if _, hasRuntime := raw["runtime"]; hasRuntime {
		return parseHubManifest(data)
	}

	// Standard client manifest - use flexible parsing for schema_version
	return parseClientManifest(data, raw)
}

// parseClientManifest parses the standard client manifest format,
// handling schema_version as either string or number.
func parseClientManifest(data []byte, _ map[string]json.RawMessage) (*Manifest, error) {
	var m Manifest
	if err := json.Unmarshal(data, &m); err != nil {
		// If it fails, try handling schema_version as a number
		if strings.Contains(err.Error(), "schema_version") {
			return parseClientManifestFlexible(data)
		}
		return nil, fmt.Errorf("failed to parse manifest JSON: %w", err)
	}
	return &m, nil
}

// parseClientManifestFlexible handles schema_version as either int or string.
func parseClientManifestFlexible(data []byte) (*Manifest, error) {
	type flexManifest struct {
		SchemaVersion json.Number     `json:"schema_version"`
		Package       PackageInfo     `json:"package"`
		Bundle        BundleInfo      `json:"bundle"`
		Transport     TransportInfo   `json:"transport"`
		Entrypoints   []Entrypoint    `json:"entrypoints"`
		Permissions   PermissionsInfo `json:"permissions_requested"`
		Limits        LimitsInfo      `json:"limits_recommended"`
	}

	var fm flexManifest
	if err := json.Unmarshal(data, &fm); err != nil {
		return nil, fmt.Errorf("failed to parse manifest JSON: %w", err)
	}

	return &Manifest{
		SchemaVersion: fm.SchemaVersion.String(),
		Package:       fm.Package,
		Bundle:        fm.Bundle,
		Transport:     fm.Transport,
		Entrypoints:   fm.Entrypoints,
		Permissions:   fm.Permissions,
		Limits:        fm.Limits,
	}, nil
}

// parseHubManifest parses the hub-generated manifest format and maps it
// to the client's internal Manifest structure.
func parseHubManifest(data []byte) (*Manifest, error) {
	var hm hubManifest
	if err := json.Unmarshal(data, &hm); err != nil {
		return nil, fmt.Errorf("failed to parse hub manifest: %w", err)
	}

	// Determine OS and arch from runtime.platform
	epOS := "linux"
	epArch := "amd64"
	if hm.Runtime.Platform != nil {
		if hm.Runtime.Platform.OS != "" {
			epOS = hm.Runtime.Platform.OS
		}
		if hm.Runtime.Platform.Arch != "" {
			epArch = hm.Runtime.Platform.Arch
		}
	}

	// Map entrypoint command: hub uses ["node", "dist/index.js"]
	// We set Command to the runtime binary and Args to the rest
	var command string
	var args []string
	if len(hm.Entrypoint.Command) > 0 {
		command = hm.Entrypoint.Command[0]
		if len(hm.Entrypoint.Command) > 1 {
			args = hm.Entrypoint.Command[1:]
		}
	}
	// Append any extra args from the entrypoint definition
	args = append(args, hm.Entrypoint.Args...)

	m := &Manifest{
		SchemaVersion: hm.SchemaVersion.String(),
		Package: PackageInfo{
			ID:      hm.Package.ID,
			Version: hm.Package.Version,
			GitSHA:  hm.Package.GitSHA,
		},
		Transport: TransportInfo{
			Type: "stdio", // Hub MCPs default to stdio transport
		},
		Entrypoints: []Entrypoint{
			{
				OS:      epOS,
				Arch:    epArch,
				Command: command,
				Args:    args,
			},
		},
		HubFormat: true,
	}

	// Map permissions
	// Hub manifests don't have a subprocess field; default to allowing subprocess
	// since system commands (uv, node) require spawning child processes.
	m.Permissions.Subprocess = true
	if hm.Permissions != nil {
		if hm.Permissions.Network != nil {
			m.Permissions.Network = hm.Permissions.Network.Outbound
		}
		if hm.Permissions.Filesystem != nil {
			m.Permissions.FileSystem = append(m.Permissions.FileSystem, hm.Permissions.Filesystem.Read...)
			m.Permissions.FileSystem = append(m.Permissions.FileSystem, hm.Permissions.Filesystem.Write...)
		}
		m.Permissions.Environment = hm.Permissions.EnvVars
	}

	// Map resources to limits
	if hm.Resources != nil {
		m.Limits.MaxCPU = hm.Resources.CPUMillicores
		if hm.Resources.MemoryMB > 0 {
			m.Limits.MaxMemory = fmt.Sprintf("%dM", hm.Resources.MemoryMB)
		}
		if hm.Resources.TimeoutSeconds > 0 {
			m.Limits.Timeout = fmt.Sprintf("%ds", hm.Resources.TimeoutSeconds)
		}
	}

	return m, nil
}

// Validate validates a manifest schema and required fields.
// Hub-format manifests skip bundle validation since bundle info
// comes from the resolve response, not the manifest itself.
func Validate(manifest *Manifest) error {
	if manifest == nil {
		return fmt.Errorf("manifest cannot be nil")
	}

	// Validate schema version
	if manifest.SchemaVersion == "" {
		return fmt.Errorf("schema_version is required")
	}

	// Validate package info
	if manifest.Package.ID == "" {
		return fmt.Errorf("package.id is required")
	}
	if !isValidPackageID(manifest.Package.ID) {
		return fmt.Errorf("package.id must be in format 'org/name', got: %s", manifest.Package.ID)
	}
	if manifest.Package.Version == "" {
		return fmt.Errorf("package.version is required")
	}

	// Validate bundle info (skip for hub-format manifests where bundle info comes from resolve)
	if !manifest.HubFormat {
		if manifest.Bundle.Digest == "" {
			return fmt.Errorf("bundle.digest is required")
		}
		if !isValidDigest(manifest.Bundle.Digest) {
			return fmt.Errorf("bundle.digest must be a valid SHA-256 digest (sha256:hex...)")
		}
		if manifest.Bundle.SizeBytes <= 0 {
			return fmt.Errorf("bundle.size_bytes must be > 0")
		}
	}

	// Validate transport info
	if manifest.Transport.Type == "" {
		return fmt.Errorf("transport.type is required")
	}
	if manifest.Transport.Type != "stdio" && manifest.Transport.Type != "http" {
		return fmt.Errorf("transport.type must be 'stdio' or 'http', got: %s", manifest.Transport.Type)
	}
	if manifest.Transport.Type == "http" && manifest.Transport.Port <= 0 {
		return fmt.Errorf("transport.port is required for http transport")
	}

	// Validate entrypoints
	if len(manifest.Entrypoints) == 0 {
		return fmt.Errorf("at least one entrypoint is required")
	}
	for i, ep := range manifest.Entrypoints {
		if ep.OS == "" {
			return fmt.Errorf("entrypoints[%d].os is required", i)
		}
		if !isValidOS(ep.OS) {
			return fmt.Errorf("entrypoints[%d].os must be 'linux', 'darwin', or 'windows', got: %s", i, ep.OS)
		}
		if ep.Arch == "" {
			return fmt.Errorf("entrypoints[%d].arch is required", i)
		}
		if !isValidArch(ep.Arch) {
			return fmt.Errorf("entrypoints[%d].arch must be 'amd64' or 'arm64', got: %s", i, ep.Arch)
		}
		if ep.Command == "" {
			return fmt.Errorf("entrypoints[%d].command is required", i)
		}
	}

	return nil
}

// SelectEntrypoint selects the appropriate entrypoint for the current OS/arch.
// For hub-format manifests with a single entrypoint, it returns that entrypoint
// regardless of OS/arch since the hub defines platform in the runtime section.
func SelectEntrypoint(manifest *Manifest) (*Entrypoint, error) {
	if manifest == nil {
		return nil, fmt.Errorf("manifest cannot be nil")
	}

	currentOS := runtime.GOOS
	currentArch := runtime.GOARCH

	// Try exact match first
	for i := range manifest.Entrypoints {
		ep := &manifest.Entrypoints[i]
		if ep.OS == currentOS && ep.Arch == currentArch {
			return ep, nil
		}
	}

	// For hub-format manifests with a single entrypoint, use it as a fallback.
	// Hub manifests define platform in runtime.platform and may not match the
	// client's OS/arch exactly (e.g., hub defaults to linux/amd64 but the MCP
	// may be a Node.js script that runs on any platform).
	if manifest.HubFormat && len(manifest.Entrypoints) == 1 {
		ep := &manifest.Entrypoints[0]
		return ep, nil
	}

	return nil, fmt.Errorf("no entrypoint found for %s/%s", currentOS, currentArch)
}

// IsSystemCommand checks if a command refers to a system binary (like node, python)
// rather than a binary inside the bundle directory.
func IsSystemCommand(command string) bool {
	systemCommands := []string{
		"node", "python", "python3", "ruby", "java", "deno", "bun",
		"npx", "uvx", "uv",
	}
	for _, sc := range systemCommands {
		if command == sc {
			return true
		}
	}
	return false
}

// isValidPackageID validates package ID format (org/name)
func isValidPackageID(id string) bool {
	parts := strings.Split(id, "/")
	if len(parts) != 2 {
		return false
	}
	if parts[0] == "" || parts[1] == "" {
		return false
	}
	// Allow alphanumeric, hyphens, underscores
	re := regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)
	return re.MatchString(parts[0]) && re.MatchString(parts[1])
}

// isValidDigest validates SHA-256 digest format
func isValidDigest(digest string) bool {
	// Format: sha256:hexstring (64 hex chars after colon)
	re := regexp.MustCompile(`^sha256:[a-f0-9]{64}$`)
	return re.MatchString(digest)
}

// isValidOS validates supported operating systems
func isValidOS(os string) bool {
	return os == "linux" || os == "darwin" || os == "windows"
}

// isValidArch validates supported architectures
func isValidArch(arch string) bool {
	return arch == "amd64" || arch == "arm64"
}
